using UnityEngine;
using System.Collections.Generic;

public class PlayerCompletionManager : MonoBehaviour
{
    private HashSet<int> completedPlayerIDs = new HashSet<int>();

    void Start()
    {
        PathInput.OnPlayerCompleted += HandlePlayerCompleted;
    }

    void OnDestroy()
    {
        PathInput.OnPlayerCompleted -= HandlePlayerCompleted;
    }

    public void HandlePlayerCompleted(Player player)
    {
        if (player == null) return;
        completedPlayerIDs.Add(player.playerID);
    }

    public bool IsPlayerCompleted(int playerID)
    {
        return completedPlayerIDs.Contains(playerID);
    }

    public void ResetAllPlayers()
    {
        completedPlayerIDs.Clear();
    }
}using UnityEngine;
using System.Collections.Generic;

public class GoalSelectionIndicator : MonoBehaviour
{
    [Header("Goal Visual Settings")]
    [SerializeField] private float scaleMultiplier = 1.2f;
    [SerializeField] private SelectionVisualType visualType = SelectionVisualType.Scale;

    private Dictionary<int, GameObject> playerGoalObjects = new Dictionary<int, GameObject>();
    private Dictionary<GameObject, Vector3> originalGoalScales = new Dictionary<GameObject, Vector3>();
    private Player currentSelectedPlayer;

    public enum SelectionVisualType
    {
        Scale,
        Pulse,
        ColorIntensify
    }
    void Start()
    {
        PathInput.OnPlayerSelectionChanged += HandlePlayerSelection;
        PathInput.OnPlayerCompleted += HandlePlayerCompleted;
        StartCoroutine(DelayedFindGoals());
    }

    void OnDestroy()
    {
        PathInput.OnPlayerSelectionChanged -= HandlePlayerSelection;
        PathInput.OnPlayerCompleted -= HandlePlayerCompleted;
    }

    public void HandlePlayerCompleted(Player player)
    {
        if (currentSelectedPlayer == player)
        {
            ResetGoalVisual(player.playerID);
            currentSelectedPlayer = null;
        }
    }
    System.Collections.IEnumerator DelayedFindGoals()
    {
        yield return new WaitForSeconds(0.5f);
        FindAllGoalObjects();

        if (playerGoalObjects.Count == 0)
        {
            yield return new WaitForSeconds(0.5f);
            FindAllGoalObjects();
        }
    }
    void FindAllGoalObjects()
    {
        if (PlayerManager.Instance != null && LevelManager.Instance?.currentLevelData?.players != null)
        {
            List<GameObject> allGoals = PlayerManager.Instance.GetAllGoals();

            for (int i = 0; i < allGoals.Count && i < LevelManager.Instance.currentLevelData.players.Length; i++)
            {
                GameObject goalObj = allGoals[i];
                var playerData = LevelManager.Instance.currentLevelData.players[i];

                playerGoalObjects[playerData.playerID] = goalObj;
                originalGoalScales[goalObj] = goalObj.transform.localScale;
            }
        }
    }

    public void HandlePlayerSelection(Player selectedPlayer)
    {
        if (currentSelectedPlayer != null)
        {
            ResetGoalVisual(currentSelectedPlayer.playerID);
        }

        currentSelectedPlayer = selectedPlayer;
        if (selectedPlayer != null)
        {
            ApplyGoalVisual(selectedPlayer.playerID);
        }
    }

    void ApplyGoalVisual(int playerID)
    {
        if (playerGoalObjects.ContainsKey(playerID))
        {
            GameObject goalObj = playerGoalObjects[playerID];

            switch (visualType)
            {
                case SelectionVisualType.Scale:
                    goalObj.transform.localScale = originalGoalScales[goalObj] * scaleMultiplier;
                    break;
                case SelectionVisualType.Pulse:
                    StartCoroutine(PulseGoal(goalObj));
                    break;
                case SelectionVisualType.ColorIntensify:
                    IntensifyGoalColor(goalObj);
                    break;
            }
        }
    }

    void ResetGoalVisual(int playerID)
    {
        if (playerGoalObjects.ContainsKey(playerID))
        {
            GameObject goalObj = playerGoalObjects[playerID];
            goalObj.transform.localScale = originalGoalScales[goalObj];

            // Pulse 중단
            StopAllCoroutines();
        }
    }

    System.Collections.IEnumerator PulseGoal(GameObject goalObj)
    {
        Vector3 originalScale = originalGoalScales[goalObj];

        while (currentSelectedPlayer != null)
        {
            float pulse = (Mathf.Sin(Time.time * 2f) + 1f) / 2f;
            goalObj.transform.localScale = Vector3.Lerp(originalScale, originalScale * scaleMultiplier, pulse);
            yield return null;
        }
    }

    void IntensifyGoalColor(GameObject goalObj)
    {
        SpriteRenderer renderer = goalObj.GetComponent<SpriteRenderer>();
        if (renderer != null)
        {
            Color color = renderer.color;
            color.a = Mathf.Min(1f, color.a + 0.3f); // 더 불투명하게
            renderer.color = color;
        }
    }

    public void ClearSelection()
    {
        if (currentSelectedPlayer != null)
        {
            ResetGoalVisual(currentSelectedPlayer.playerID);
            currentSelectedPlayer = null;
        }
    }
}using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class RemainingSelectionsDisplay : MonoBehaviour
{
    [Header("UI References")]
    [SerializeField] private GameObject displayPanel;
    [SerializeField] private TextMeshProUGUI playerNameText;
    [SerializeField] private TextMeshProUGUI remainingSelectionsText;
    [SerializeField] private Image playerColorIndicator;

    [Header("Display Settings")]
    [SerializeField] private bool showPlayerName = true;
    [SerializeField] private string playerNameFormat = "Player {0}";
    [SerializeField] private string selectionsFormat = "Selections: {0}/{1}";

    private Player currentSelectedPlayer;
    private int usedSelections = 0;

    void Start()
    {
        PathInput.OnPlayerSelectionChanged += HandlePlayerSelection;
        PathInput.OnPathPointAdded += HandlePathPointSelected;
        PathInput.OnPlayerCompleted += HandlePlayerCompleted;

        if (displayPanel != null)
            displayPanel.SetActive(false);
    }

    void OnDestroy()
    {
        PathInput.OnPlayerSelectionChanged -= HandlePlayerSelection;
        PathInput.OnPathPointAdded -= HandlePathPointSelected;
        PathInput.OnPlayerCompleted -= HandlePlayerCompleted;
    }

    public void HandlePlayerCompleted(Player player)
    {
        if (currentSelectedPlayer == player)
        {
            HideDisplay();
        }
    }
    public void HandlePlayerSelection(Player selectedPlayer)
    {
        currentSelectedPlayer = selectedPlayer;

        if (selectedPlayer != null)
        {
            ShowDisplay();
            UpdateDisplay();
        }
        else
        {
            HideDisplay();
        }
    }

    public void HandlePathPointSelected(Vector2Int gridPos)
    {
        if (currentSelectedPlayer != null)
        {
            // PathManager를 이벤트 기반으로 찾지 않고 PathInput에서 직접 계산해서 전달하는 방식으로 변경 예정
            // 일단 기존 코드 유지하되, FindFirstObjectByType 최소화
            var pathManager = GetComponent<PathManager>(); // 같은 오브젝트 내에서 찾기
            if (pathManager != null)
            {
                var currentPath = pathManager.GetPlayerPath(currentSelectedPlayer);
                usedSelections = Mathf.Max(0, currentPath.Count - 1);
                UpdateDisplay();
            }
        }
    }

    void ShowDisplay()
    {
        if (displayPanel != null)
            displayPanel.SetActive(true);
    }

    void HideDisplay()
    {
        if (displayPanel != null)
            displayPanel.SetActive(false);

        currentSelectedPlayer = null;
        usedSelections = 0;
    }

    void UpdateDisplay()
    {
        if (currentSelectedPlayer == null) return;

        // 플레이어 데이터 가져오기
        PlayerSpawnData playerData = PlayerManager.Instance.GetPlayerData(currentSelectedPlayer.playerID);
        if (playerData == null) return;

        int maxSelections = playerData.maxSelections;
        int remaining = maxSelections - usedSelections; // 남은 횟수 = 최대 - 사용한 횟수

        // 플레이어 이름 표시
        if (showPlayerName && playerNameText != null)
        {
            playerNameText.text = string.Format(playerNameFormat, currentSelectedPlayer.playerID);
        }

        // 남은 선택 수 표시
        if (remainingSelectionsText != null)
        {
            remainingSelectionsText.text = string.Format(selectionsFormat, remaining, maxSelections);

            // 남은 선택이 적을 때 색상 변경
            if (remaining <= 0)
                remainingSelectionsText.color = Color.red;
            else if (remaining <= 1)
                remainingSelectionsText.color = Color.yellow;
            else
                remainingSelectionsText.color = Color.white;
        }

        // 플레이어 색상 표시
        if (playerColorIndicator != null)
        {
            playerColorIndicator.color = currentSelectedPlayer.playerColor;
        }
    }
    public void UpdateSelectionsCount(Player player, int usedCount)
    {
        if (currentSelectedPlayer == player)
        {
            usedSelections = usedCount;
            UpdateDisplay();
        }
    }
    public void ClearDisplay()
    {
        HideDisplay();
    }
}using UnityEngine;

public class PlayerSelectionIndicator : MonoBehaviour
{
    [Header("Selection Visual Settings")]
    [SerializeField] private SelectionVisualType visualType = SelectionVisualType.Scale;
    [SerializeField] private float scaleMultiplier = 1.2f;
    [SerializeField] private Color highlightColor = Color.white;
    [SerializeField] private float pulseSpeed = 2f;

    private Player currentSelectedPlayer;
    private Vector3 originalScale;
    private Color originalColor;
    private SpriteRenderer spriteRenderer;

    public enum SelectionVisualType
    {
        Scale,
        ColorChange,
        Pulse,
        TextBox
    }

    void Start()
    {
        PathInput.OnPlayerSelectionChanged += HandlePlayerSelection;
        PathInput.OnPlayerCompleted += HandlePlayerCompleted;
    }

    void OnDestroy()
    {
        PathInput.OnPlayerSelectionChanged -= HandlePlayerSelection;
        PathInput.OnPlayerCompleted -= HandlePlayerCompleted;
    }

    public void HandlePlayerSelection(Player selectedPlayer)
    {
        if (currentSelectedPlayer != null)
        {
            ResetPlayerVisual();
        }

        currentSelectedPlayer = selectedPlayer;
        if (selectedPlayer != null)
        {
            ApplySelectionVisual();
        }
    }

    public void HandlePlayerCompleted(Player player)
    {
        if (currentSelectedPlayer == player)
        {
            ResetPlayerVisual();
            currentSelectedPlayer = null;
        }
    }

    void ApplySelectionVisual()
    {
        if (currentSelectedPlayer == null) return;

        var completionManager = GetComponent<PlayerCompletionManager>();
        if (completionManager != null && completionManager.IsPlayerCompleted(currentSelectedPlayer.playerID))
        {
            return;
        }

        spriteRenderer = currentSelectedPlayer.GetComponent<SpriteRenderer>();
        if (spriteRenderer == null) return;

        originalScale = currentSelectedPlayer.transform.localScale;
        originalColor = spriteRenderer.color;

        switch (visualType)
        {
            case SelectionVisualType.Scale:
                currentSelectedPlayer.transform.localScale = originalScale * scaleMultiplier;
                break;
            case SelectionVisualType.ColorChange:
                spriteRenderer.color = highlightColor;
                break;
            case SelectionVisualType.Pulse:
                StartCoroutine(PulseEffect());
                break;
        }
    }

    System.Collections.IEnumerator PulseEffect()
    {
        while (currentSelectedPlayer != null)
        {
            float pulse = (Mathf.Sin(Time.time * pulseSpeed) + 1f) / 2f;
            currentSelectedPlayer.transform.localScale = Vector3.Lerp(originalScale, originalScale * scaleMultiplier, pulse);
            yield return null;
        }
    }

    void ResetPlayerVisual()
    {
        if (currentSelectedPlayer == null) return;

        currentSelectedPlayer.transform.localScale = originalScale;
        if (spriteRenderer != null)
        {
            spriteRenderer.color = originalColor;
        }
        StopAllCoroutines();
    }

    public void ClearSelection()
    {
        if (currentSelectedPlayer != null)
        {
            ResetPlayerVisual();
            currentSelectedPlayer = null;
        }
    }
}using UnityEngine;
using System.Collections.Generic;

public class PathManager : MonoBehaviour
{
    private Dictionary<Player, List<Vector2Int>> playerPaths = new Dictionary<Player, List<Vector2Int>>();
    private List<Player> cachedPlayers = new List<Player>();

    void Start()
    {
        CacheAllPlayers();
    }

    public void AddPlayerToCache(Player player)
    {
        if (!cachedPlayers.Contains(player))
        {
            cachedPlayers.Add(player);
            InitializePlayerPath(player);
        }
    }

    void CacheAllPlayers()
    {
        cachedPlayers.Clear();
        Player[] allPlayers = FindObjectsByType<Player>(FindObjectsSortMode.None);

        foreach (Player player in allPlayers)
        {
            cachedPlayers.Add(player);
            InitializePlayerPath(player);
        }
    }

    void InitializePlayerPath(Player player)
    {
        if (!playerPaths.ContainsKey(player))
        {
            playerPaths[player] = new List<Vector2Int>();
        }
    }

    public List<Vector2Int> GetPlayerPath(Player player)
    {
        if (playerPaths.ContainsKey(player))
        {
            return playerPaths[player];
        }
        return new List<Vector2Int>();
    }

    public void SetPlayerPath(Player player, List<Vector2Int> path)
    {
        if (!playerPaths.ContainsKey(player))
        {
            playerPaths[player] = new List<Vector2Int>();
        }
        playerPaths[player] = new List<Vector2Int>(path);
    }

    public void AddPointToPath(Player player, Vector2Int point)
    {
        if (!playerPaths.ContainsKey(player))
        {
            playerPaths[player] = new List<Vector2Int>();
        }
        playerPaths[player].Add(point);
    }

    public void ClearPlayerPath(Player player)
    {
        if (playerPaths.ContainsKey(player))
        {
            playerPaths[player].Clear();
        }
    }

    public void ClearAllPaths()
    {
        foreach (var path in playerPaths.Values)
        {
            path.Clear();
        }
    }

    public bool AreAllPlayersComplete()
    {
        if (LevelManager.Instance?.currentLevelData?.players == null) return false;

        foreach (var playerData in LevelManager.Instance.currentLevelData.players)
        {
            Player playerObj = null;
            foreach (var kvp in playerPaths)
            {
                if (kvp.Key.playerID == playerData.playerID)
                {
                    playerObj = kvp.Key;
                    break;
                }
            }

            if (playerObj == null) return false;

            List<Vector2Int> path = playerPaths[playerObj];
            if (path.Count == 0) return false;

            Vector2Int lastPoint = path[path.Count - 1];
            if (lastPoint != playerData.goalPosition) return false;
        }

        return true;
    }

    public void ExecuteAllPaths()
    {
        foreach (var kvp in playerPaths)
        {
            Player player = kvp.Key;
            List<Vector2Int> fullPath = kvp.Value;

            if (fullPath.Count > 1)
            {
                List<Vector2Int> playerPath = new List<Vector2Int>(fullPath);
                playerPath.RemoveAt(0);

                player.SetPath(playerPath);
                player.StartMoving();
            }
        }

        // 실행 후 경로 데이터 정리
        playerPaths.Clear();
    }

    public bool IsAnyPlayerMoving()
    {
        foreach (Player player in cachedPlayers)
        {
            if (player != null && player.IsMoving()) return true;
        }
        return false;
    }
}using UnityEngine;
using System.Collections.Generic;

public class PathVisualizer : MonoBehaviour
{
    [Header("Path Colors")]
    public Color validPathColor = Color.yellow;
    public Color invalidPathColor = Color.red;

    private LineRenderer hoverLineRenderer;
    private Dictionary<Player, LineRenderer> playerPathRenderers = new Dictionary<Player, LineRenderer>();

    void Start()
    {
        CreateHoverLineRenderer();
    }

    void CreateHoverLineRenderer()
    {
        GameObject hoverObj = new GameObject("HoverPathLine");
        hoverObj.transform.SetParent(transform);

        hoverLineRenderer = hoverObj.AddComponent<LineRenderer>();

        Material lineMat = new Material(Shader.Find("Sprites/Default"));
        hoverLineRenderer.material = lineMat;

        hoverLineRenderer.startWidth = 0.15f;
        hoverLineRenderer.endWidth = 0.15f;
        hoverLineRenderer.positionCount = 0;
        hoverLineRenderer.sortingOrder = 2;
        hoverLineRenderer.useWorldSpace = true;
        hoverLineRenderer.startColor = validPathColor;
        hoverLineRenderer.endColor = validPathColor;
    }

    public void InitializePlayerPathRenderer(Player player)
    {
        if (playerPathRenderers.ContainsKey(player)) return;

        GameObject pathObj = new GameObject($"PathLine_Player{player.playerID}");
        pathObj.transform.SetParent(transform);

        LineRenderer pathRenderer = pathObj.AddComponent<LineRenderer>();

        Material pathMat = new Material(Shader.Find("Sprites/Default"));
        pathRenderer.material = pathMat;

        pathRenderer.startColor = player.playerColor;
        pathRenderer.endColor = player.playerColor;
        pathRenderer.startWidth = 0.12f;
        pathRenderer.endWidth = 0.12f;
        pathRenderer.positionCount = 0;
        pathRenderer.sortingOrder = 1;
        pathRenderer.useWorldSpace = true;

        playerPathRenderers[player] = pathRenderer;
    }

    public void UpdatePlayerPath(Player player, List<Vector2Int> path)
    {
        if (!playerPathRenderers.ContainsKey(player)) return;

        LineRenderer pathRenderer = playerPathRenderers[player];

        if (path.Count < 2)
        {
            pathRenderer.positionCount = 0;
            return;
        }

        pathRenderer.positionCount = path.Count;
        for (int i = 0; i < path.Count; i++)
        {
            Vector3 worldPos = GridManager.Instance.GridToWorld(path[i]);
            pathRenderer.SetPosition(i, worldPos);
        }
    }

    public void ShowHoverPath(Vector2Int from, Vector2Int to, bool isValid)
    {
        Color color = isValid ? validPathColor : invalidPathColor;
        hoverLineRenderer.startColor = color;
        hoverLineRenderer.endColor = color;
        hoverLineRenderer.positionCount = 2;

        Vector3 startWorldPos = GridManager.Instance.GridToWorld(from);
        Vector3 endWorldPos = GridManager.Instance.GridToWorld(to);

        hoverLineRenderer.SetPosition(0, startWorldPos);
        hoverLineRenderer.SetPosition(1, endWorldPos);
    }

    public void HideHoverPath()
    {
        hoverLineRenderer.positionCount = 0;
    }

    public void CompletePlayerPath(Player player)
    {
        if (!playerPathRenderers.ContainsKey(player)) return;

        LineRenderer pathRenderer = playerPathRenderers[player];
        pathRenderer.startColor = Color.black;
        pathRenderer.endColor = Color.black;

        StartCoroutine(HidePathAfterDelay(pathRenderer, 1.0f));
    }

    // HidePathAfterDelay 메서드 수정 - 선택 해제 코드 제거
    System.Collections.IEnumerator HidePathAfterDelay(LineRenderer pathRenderer, float delay)
    {
        yield return new WaitForSeconds(delay);
        pathRenderer.positionCount = 0;

        // 기존의 선택 해제 코드 제거됨
        // OnPlayerCompleted 이벤트가 모든 완료 처리를 담당
    }

    public void ClearAllLineRenderers()
    {
        foreach (var pathRenderer in playerPathRenderers.Values)
        {
            if (pathRenderer != null && pathRenderer.gameObject != null)
            {
                DestroyImmediate(pathRenderer.gameObject);
            }
        }

        playerPathRenderers.Clear();

        if (hoverLineRenderer != null)
        {
            hoverLineRenderer.positionCount = 0;
        }
    }
}using UnityEngine;
using System.Collections.Generic;

public class PathValidator : MonoBehaviour
{
    public bool IsValidPathPoint(Vector2Int gridPos, Player selectedPlayer, List<Vector2Int> currentPath)
    {
        if (!HasTileAtPosition(gridPos)) return false;

        Vector2Int lastPos = GetLastPathPoint(selectedPlayer, currentPath);
        if (!IsStraightLine(lastPos, gridPos)) return false;

        if (IsOtherPlayerGoal(gridPos, selectedPlayer)) return false;
        if (IsOtherPlayerStart(gridPos, selectedPlayer)) return false;
        if (!CanAddMorePoints(selectedPlayer, currentPath)) return false;
        if (IsDuplicatePoint(gridPos, currentPath)) return false;
        if (!CanReachGoalAfterThisSelection(gridPos, selectedPlayer, currentPath)) return false;

        return true;
    }

    public bool HasTileAtPosition(Vector2Int gridPos)
    {
        if (LevelManager.Instance?.mainTilemap == null) return false;

        Vector3 worldPos = GridManager.Instance.GridToWorld(gridPos);
        Vector3Int tilemapPos = LevelManager.Instance.mainTilemap.WorldToCell(worldPos);
        return LevelManager.Instance.mainTilemap.GetTile(tilemapPos) != null;
    }

    public bool IsStraightLine(Vector2Int from, Vector2Int to)
    {
        Vector2Int diff = to - from;
        return (diff.x == 0 && diff.y != 0) || (diff.y == 0 && diff.x != 0);
    }

    public bool IsOtherPlayerGoal(Vector2Int gridPos, Player selectedPlayer)
    {
        if (LevelManager.Instance?.currentLevelData?.players == null) return false;

        foreach (var playerData in LevelManager.Instance.currentLevelData.players)
        {
            if (playerData.playerID != selectedPlayer.playerID &&
                playerData.goalPosition == gridPos)
            {
                return true;
            }
        }
        return false;
    }

    public bool IsOtherPlayerStart(Vector2Int gridPos, Player selectedPlayer)
    {
        if (LevelManager.Instance?.currentLevelData?.players == null) return false;

        foreach (var playerData in LevelManager.Instance.currentLevelData.players)
        {
            if (playerData.playerID != selectedPlayer.playerID &&
                playerData.startPosition == gridPos)
            {
                return true;
            }
        }
        return false;
    }

    public bool CanAddMorePoints(Player selectedPlayer, List<Vector2Int> currentPath)
    {
        PlayerSpawnData playerData = PlayerManager.Instance.GetPlayerData(selectedPlayer.playerID);
        int maxSelections = playerData != null ? playerData.maxSelections : GameManager.Instance.GetMaxSelections();
        return currentPath.Count < maxSelections + 1;
    }

    public bool IsDuplicatePoint(Vector2Int gridPos, List<Vector2Int> currentPath)
    {
        if (currentPath.Count > 0 && currentPath[currentPath.Count - 1] == gridPos) return true;
        return false;
    }

    public bool CanReachGoalAfterThisSelection(Vector2Int targetPos, Player selectedPlayer, List<Vector2Int> currentPath)
    {
        PlayerSpawnData playerData = PlayerManager.Instance.GetPlayerData(selectedPlayer.playerID);
        int maxSelections = playerData != null ? playerData.maxSelections : GameManager.Instance.GetMaxSelections();
        int usedAfterThis = currentPath.Count + 1;
        int remainingAfterThis = maxSelections + 1 - usedAfterThis;

        Vector2Int ownGoalPos = GetOwnGoalPosition(selectedPlayer);

        if (remainingAfterThis == 0)
        {
            return targetPos == ownGoalPos;
        }

        if (remainingAfterThis == 1)
        {
            Vector2Int diff = ownGoalPos - targetPos;
            return (diff.x == 0) || (diff.y == 0);
        }

        return true;
    }

    public Vector2Int GetLastPathPoint(Player selectedPlayer, List<Vector2Int> currentPath)
    {
        if (currentPath.Count > 0)
            return currentPath[currentPath.Count - 1];
        else
            return selectedPlayer.GetGridPosition();
    }

    public Vector2Int GetOwnGoalPosition(Player selectedPlayer)
    {
        if (LevelManager.Instance?.currentLevelData?.players == null) return Vector2Int.zero;

        foreach (var playerData in LevelManager.Instance.currentLevelData.players)
        {
            if (playerData.playerID == selectedPlayer.playerID)
            {
                return playerData.goalPosition;
            }
        }
        return Vector2Int.zero;
    }

    public bool IsPlayerOwnGoal(Vector2Int gridPos, Player selectedPlayer)
    {
        if (LevelManager.Instance?.currentLevelData?.players == null) return false;

        foreach (var playerData in LevelManager.Instance.currentLevelData.players)
        {
            if (playerData.playerID == selectedPlayer.playerID &&
                playerData.goalPosition == gridPos)
            {
                return true;
            }
        }
        return false;
    }
}using UnityEngine;

public class InputHandler : MonoBehaviour
{
    public delegate void PlayerSelectedHandler(Player player);
    public delegate void PathPointSelectedHandler(Vector2Int gridPos);

    public event PlayerSelectedHandler OnPlayerSelected;
    public event PathPointSelectedHandler OnPathPointSelected;

    [Header("Input Settings")]
    public LayerMask playerLayerMask = -1;

    private Camera mainCamera;
    private bool isDragging = false;
    private Vector3 lastInputPosition;

    void Start()
    {
        mainCamera = Camera.main;
    }

    void Update()
    {
        HandleInput();

        Vector3 currentInputPosition = GetCurrentInputPosition();
        if (currentInputPosition != lastInputPosition)
        {
            if (isDragging)
            {
                // 드래그 이벤트는 PathVisualizer에서 처리
            }
            lastInputPosition = currentInputPosition;
        }
    }

    Vector3 GetCurrentInputPosition()
    {
        if (Input.touchCount > 0)
        {
            return Input.GetTouch(0).position;
        }
        else
        {
            return Input.mousePosition;
        }
    }

    void HandleInput()
    {
        if (Input.touchCount > 0)
        {
            Touch touch = Input.GetTouch(0);

            if (touch.phase == TouchPhase.Began)
            {
                HandleTouchBegan();
            }
            else if (touch.phase == TouchPhase.Moved)
            {
                isDragging = true;
            }
            else if (touch.phase == TouchPhase.Ended)
            {
                HandleTouchEnded();
                isDragging = false;
            }
        }
        else
        {
            if (Input.GetMouseButtonDown(0))
            {
                HandleTouchBegan();
            }
            if (Input.GetMouseButton(0))
            {
                isDragging = true;
            }
            if (Input.GetMouseButtonUp(0))
            {
                HandleTouchEnded();
                isDragging = false;
            }
        }

        if (Input.GetKeyDown(KeyCode.Space))
        {
            GameManager.Instance.StartSimulation();
        }
    }

    void HandleTouchBegan()
    {
        Vector3 worldPos = GetWorldPosition();

        Collider2D hitCollider = Physics2D.OverlapPoint(worldPos, playerLayerMask);
        if (hitCollider != null)
        {
            Player player = hitCollider.GetComponent<Player>();
            if (player != null)
            {
                OnPlayerSelected?.Invoke(player);
                return;
            }
        }
    }

    void HandleTouchEnded()
    {
        Vector3 worldPos = GetWorldPosition();
        Vector2Int gridPos = GridManager.Instance.WorldToGrid(worldPos);
        OnPathPointSelected?.Invoke(gridPos);
    }

    public Vector3 GetWorldPosition()
    {
        Vector3 screenPos;

        if (Input.touchCount > 0)
        {
            screenPos = Input.GetTouch(0).position;
        }
        else
        {
            screenPos = Input.mousePosition;
        }

        screenPos.z = 10f;
        return mainCamera.ScreenToWorldPoint(screenPos);
    }

    public bool IsDragging()
    {
        return isDragging;
    }
}using UnityEngine;
using System.Collections.Generic;

public class PlayerManager : MonoBehaviour
{
    [Header("Player Management")]
    public GameObject playerPrefab;
    public GameObject goalPrefab;

    private List<Player> allPlayers = new List<Player>();
    private Dictionary<int, Player> playersByID = new Dictionary<int, Player>();
    private List<GameObject> allGoals = new List<GameObject>();
    private PathInput pathInput;

    private static PlayerManager instance;
    public static PlayerManager Instance { get { return instance; } }
    void Awake()
    {
        if (instance == null)
        {
            instance = this;
            pathInput = FindFirstObjectByType<PathInput>(); // 추가
        }
        else
        {
            Destroy(gameObject);
        }
    }

    public void SpawnPlayer(PlayerSpawnData playerData)
    {
        // 플레이어 스폰
        Vector3 playerWorldPos = GridManager.Instance.GridToWorld(playerData.startPosition);
        GameObject playerObj = Instantiate(playerPrefab, playerWorldPos, Quaternion.identity);

        Player player = playerObj.GetComponent<Player>();
        if (player != null)
        {
            player.playerID = playerData.playerID;
            player.playerColor = playerData.playerColor;

            allPlayers.Add(player);
            playersByID[playerData.playerID] = player;

            // PathInput에 캐시 추가
            if (pathInput != null)
            {
                pathInput.AddPlayerToCache(player);
            }
        }

        // 목표 스폰
        Vector3 goalWorldPos = GridManager.Instance.GridToWorld(playerData.goalPosition);
        GameObject goalObj = Instantiate(goalPrefab, goalWorldPos, Quaternion.identity);

        SpriteRenderer goalRenderer = goalObj.GetComponent<SpriteRenderer>();
        if (goalRenderer != null)
        {
            Color goalColor = playerData.playerColor;
            goalColor.a = 0.5f;
            goalRenderer.color = goalColor;
        }

        allGoals.Add(goalObj);
    }
    public void StopAllPlayers()
    {
        foreach (var player in allPlayers)
        {
            if (player != null)
            {
                player.ForceStop();
            }
        }
    }
    public PlayerSpawnData GetPlayerData(int playerID)
    {
        if (LevelManager.Instance?.currentLevelData?.players == null) return null;

        foreach (var playerData in LevelManager.Instance.currentLevelData.players)
        {
            if (playerData.playerID == playerID)
                return playerData;
        }
        return null;
    }
    public Player GetPlayerByID(int playerID)
    {
        return playersByID.ContainsKey(playerID) ? playersByID[playerID] : null;
    }
    public List<GameObject> GetAllGoals()
    {
        return new List<GameObject>(allGoals);
    }
    public List<Player> GetAllPlayers()
    {
        return new List<Player>(allPlayers);
    }

    public void ClearAllPlayers()
    {
        foreach (var player in allPlayers)
        {
            if (player != null) DestroyImmediate(player.gameObject);
        }
        allPlayers.Clear();
        playersByID.Clear();

        foreach (var goal in allGoals)
        {
            if (goal != null) DestroyImmediate(goal);
        }
        allGoals.Clear();
    }
}using UnityEngine;
using UnityEngine.Tilemaps;
using System.Collections.Generic;

public class LevelManager : MonoBehaviour
{
    [Header("Current Level")]
    public LevelData currentLevelData;

    [Header("Tile References")]
    public TileData walkableTileData;
    public TileData blockedTileData;
    public TileData startTileData;
    public TileData goalTileData;

    [Header("Tilemap References")]
    public Tilemap mainTilemap;
    public TilemapRenderer tilemapRenderer;

    [Header("Tile Mapping")]
    [SerializeField] private TileBase walkableTileAsset;
    [SerializeField] private TileBase blockedTileAsset;
    [SerializeField] private TileBase startTileAsset;
    [SerializeField] private TileBase goalTileAsset;

    [Header("Level Generation Settings")]
    [SerializeField] private int numberOfPlayers = 2;
    [SerializeField] private PlayerEditorData[] playerSettings = new PlayerEditorData[2];

    [System.Serializable]
    public class PlayerEditorData
    {
        public Color playerColor = Color.red;
        public Vector2Int startPosition = Vector2Int.zero;
        public Vector2Int goalPosition = Vector2Int.zero;
        public int maxSelections = 3;
    }


    private Dictionary<TileType, TileBase> tileAssets = new Dictionary<TileType, TileBase>();

    // 싱글톤 패턴
    private static LevelManager instance;
    public static LevelManager Instance { get { return instance; } }

    void Awake()
    {
        if (instance == null)
        {
            instance = this;
        }
        else
        {
            Destroy(gameObject);
        }
    }
    
    void Start()
    {
        InitializeTileAssets();

        if (currentLevelData != null)
        {
            LoadLevel(currentLevelData);
        }
    }

    void InitializeTileAssets()
    {
        // Tile Mapping에서 설정한 에셋들을 그대로 사용
        tileAssets[TileType.Walkable] = walkableTileAsset;
        tileAssets[TileType.Blocked] = blockedTileAsset;
        tileAssets[TileType.Start] = startTileAsset;
        tileAssets[TileType.Goal] = goalTileAsset;
    }

    public void LoadLevel(LevelData levelData)
    {
        if (!levelData.IsValid())
        {
            Debug.LogError("Invalid level data!");
            return;
        }

        currentLevelData = levelData;

        // 기존 레벨 정리
        ClearLevel();

        // Grid 설정 업데이트
        UpdateGridSettings();

        // 타일맵 생성
        GenerateTilemap();

        // 플레이어 및 목표 스폰
        SpawnPlayersAndGoals();

        Debug.Log($"Level {levelData.levelID} loaded: {levelData.levelName}");
    }

    void ClearLevel()
    {
        // 기존 타일맵 클리어
        if (mainTilemap != null)
        {
            mainTilemap.SetTilesBlock(mainTilemap.cellBounds, new TileBase[mainTilemap.cellBounds.size.x * mainTilemap.cellBounds.size.y * mainTilemap.cellBounds.size.z]);
        }

        // PathInput LineRenderer 정리
        PathInput pathInput = FindFirstObjectByType<PathInput>();
        if (pathInput != null)
        {
            pathInput.ClearAllLineRenderers();
        }

        // PlayerManager로 플레이어/목표 정리 (기존 코드 교체)
        PlayerManager.Instance.ClearAllPlayers();
    }

    void UpdateGridSettings()
    {
        if (GridManager.Instance != null)
        {
            GridManager gridManager = GridManager.Instance;
            gridManager.gridWidth = currentLevelData.gridWidth;
            gridManager.gridHeight = currentLevelData.gridHeight;
            gridManager.gridCenter = currentLevelData.gridCenter;
        }
    }

    void GenerateTilemap()
    {
        if (mainTilemap == null) return;

        foreach (var tileData in currentLevelData.tileMap)
        {
            Vector3Int cellPosition = new Vector3Int(tileData.position.x, tileData.position.y, 0);

            if (tileAssets.ContainsKey(tileData.tileType))
            {
                mainTilemap.SetTile(cellPosition, tileAssets[tileData.tileType]);
            }
        }
    }

    void SpawnPlayersAndGoals()
    {
        foreach (var playerData in currentLevelData.players)
        {
            PlayerManager.Instance.SpawnPlayer(playerData);
        }
    }

    public PlayerSpawnData GetPlayerData(int playerID)
    {
        foreach (var playerData in currentLevelData.players)
        {
            if (playerData.playerID == playerID)
                return playerData;
        }
        return null;
    }

    public bool IsValidPosition(Vector2Int gridPos)
    {
        return currentLevelData.IsWalkableTile(gridPos);
    }

    public LevelData GenerateLevelDataFromTilemap(string levelName = "Generated Level")
    {
        if (mainTilemap == null)
        {
            Debug.LogError("Main Tilemap is not assigned!");
            return null;
        }

        List<TileMapData> tileDataList = new List<TileMapData>();
        BoundsInt bounds = mainTilemap.cellBounds;

        for (int x = bounds.xMin; x < bounds.xMax; x++)
        {
            for (int y = bounds.yMin; y < bounds.yMax; y++)
            {
                Vector3Int cellPos = new Vector3Int(x, y, 0);
                TileBase tile = mainTilemap.GetTile(cellPos);

                if (tile != null)
                {
                    TileMapData tileData = new TileMapData();
                    tileData.position = new Vector2Int(x, y);
                    tileData.tileType = GetTileTypeFromAsset(tile);
                    tileData.playerID = -1;
                    tileDataList.Add(tileData);
                }
            }
        }

        Debug.Log($"Generated {tileDataList.Count} tiles from Tilemap");
        return CreateLevelDataAsset(levelName, tileDataList);
    }

    private TileType GetTileTypeFromAsset(TileBase tileAsset)
    {
        // Inspector에서 설정한 매핑 테이블과 비교
        if (tileAsset == walkableTileAsset) return TileType.Walkable;
        if (tileAsset == blockedTileAsset) return TileType.Blocked;
        if (tileAsset == startTileAsset) return TileType.Start;
        if (tileAsset == goalTileAsset) return TileType.Goal;

        // 기본값은 Walkable
        return TileType.Walkable;
    }

    // LevelData ScriptableObject 생성
    private LevelData CreateLevelDataAsset(string levelName, List<TileMapData> tiles)
    {
        LevelData newLevelData = ScriptableObject.CreateInstance<LevelData>();

        // GridManager 안전 확인
        GridManager gridManager = FindFirstObjectByType<GridManager>();
        if (gridManager == null)
        {
            Debug.LogError("GridManager not found!");
            return null;
        }

        // 기본 설정
        newLevelData.levelName = levelName;
        newLevelData.gridWidth = gridManager.gridWidth;
        newLevelData.gridHeight = gridManager.gridHeight;
        newLevelData.gridCenter = gridManager.gridCenter;

        // 타일 데이터 설정
        newLevelData.tileMap = tiles.ToArray();

        // Inspector에서 설정한 플레이어 데이터 사용
        PlayerSpawnData[] spawnDataArray = new PlayerSpawnData[numberOfPlayers];
        for (int i = 0; i < numberOfPlayers && i < playerSettings.Length; i++)
        {
            spawnDataArray[i] = new PlayerSpawnData
            {
                playerID = i + 1,
                startPosition = playerSettings[i].startPosition,
                goalPosition = playerSettings[i].goalPosition,
                playerColor = playerSettings[i].playerColor,
                maxSelections = playerSettings[i].maxSelections
            };
        }
        newLevelData.players = spawnDataArray;

        return newLevelData;
    }

#if UNITY_EDITOR
    [UnityEngine.ContextMenu("Generate Level Data")]
    public void GenerateAndSaveLevelData()
    {
        LevelData generated = GenerateLevelDataFromTilemap("Generated_" + System.DateTime.Now.ToString("yyyyMMdd_HHmm"));

        if (generated != null)
        {
            string path = "Assets/Data/" + generated.levelName + ".asset";
            UnityEditor.AssetDatabase.CreateAsset(generated, path);
            UnityEditor.AssetDatabase.SaveAssets();

            Debug.Log($"Level Data saved to: {path}");
        }
    }
#endif
}using UnityEngine;

[System.Serializable]
public class PlayerSpawnData
{
    public int playerID;
    public Vector2Int startPosition;
    public Vector2Int goalPosition;
    public Color playerColor;
    public int maxSelections;
}

[System.Serializable]
public class TileMapData
{
    public Vector2Int position;
    public TileType tileType;
    public int playerID = -1; // 시작점/목표점일 때만 사용 (-1은 해당 없음)
}

[CreateAssetMenu(fileName = "New Level Data", menuName = "PathPath/Level Data")]
public class LevelData : ScriptableObject
{
    [Header("Level Info")]
    public int levelID;
    public string levelName;
    public int difficulty = 1;

    [Header("Grid Settings")]
    public int gridWidth = 6;
    public int gridHeight = 12;
    public Vector3 gridCenter = new Vector3(2.5f, 5.5f, 0f);

    [Header("Players")]
    public PlayerSpawnData[] players;

    [Header("Tile Map")]
    public TileMapData[] tileMap;

    [Header("Game Rules")]
    public float timeLimit = 60f; // 계획 시간 제한
    public bool allowDiagonalMovement = false;

    // 유효성 검증
    public bool IsValid()
    {
        if (players == null || players.Length == 0) return false;
        if (tileMap == null || tileMap.Length == 0) return false;

        foreach (var player in players)
        {
            if (player.maxSelections <= 0) return false;
        }

        return true;
    }

    // 특정 위치의 타일 타입 반환
    public TileType GetTileTypeAt(Vector2Int position)
    {
        foreach (var tile in tileMap)
        {
            if (tile.position == position)
                return tile.tileType;
        }
        return TileType.Blocked; // 기본값은 막힌 타일
    }

    // 이동 가능한 타일인지 확인
    public bool IsWalkableTile(Vector2Int position)
    {
        TileType tileType = GetTileTypeAt(position);
        return tileType == TileType.Walkable || tileType == TileType.Start || tileType == TileType.Goal;
    }
}using UnityEngine;
using System.Collections.Generic;

public class PathInput : MonoBehaviour
{
    public static event System.Action<Player> OnPlayerSelectionChanged;
    public static event System.Action<Vector2Int> OnPathPointAdded;
    public static event System.Action<Player> OnPlayerCompleted;

    private InputHandler inputHandler;
    private PathValidator pathValidator;
    private PathVisualizer pathVisualizer;
    private PathManager pathManager;

    private Player selectedPlayer = null;
    private List<Vector2Int> currentPath = new List<Vector2Int>();

    void Awake()
    {
        InitializeComponents();
    }
    void Start()
    {
        InitializeComponents();
        SetupEventHandlers();
    }

    void InitializeComponents()
    {
        if (inputHandler == null)
            inputHandler = GetComponent<InputHandler>() ?? gameObject.AddComponent<InputHandler>();

        if (pathValidator == null)
            pathValidator = GetComponent<PathValidator>() ?? gameObject.AddComponent<PathValidator>();

        if (pathVisualizer == null)
            pathVisualizer = GetComponent<PathVisualizer>() ?? gameObject.AddComponent<PathVisualizer>();

        if (pathManager == null)
            pathManager = GetComponent<PathManager>() ?? gameObject.AddComponent<PathManager>();
    }

    void SetupEventHandlers()
    {
        inputHandler.OnPlayerSelected += HandlePlayerSelection;
        inputHandler.OnPathPointSelected += HandlePathPointSelection;
    }

    void Update()
    {
        HandleHoverAndDrag();
    }

    void HandlePathPointSelection(Vector2Int gridPos)
    {
        if (selectedPlayer == null || pathManager.IsAnyPlayerMoving()) return;
        if (IsPathCompleteToGoal()) return;

        if (pathValidator.IsValidPathPoint(gridPos, selectedPlayer, currentPath))
        {
            AddToPath(gridPos);
            // 이벤트 발생
            OnPathPointAdded?.Invoke(gridPos);
        }
    }

    // HandlePlayerSelection 메서드 수정 - 완료된 플레이어 선택 차단
    void HandlePlayerSelection(Player player)
    {
        var completionManager = GetComponent<PlayerCompletionManager>();
        if (completionManager != null && completionManager.IsPlayerCompleted(player.playerID))
        {
            return;
        }

        if (selectedPlayer != null && selectedPlayer != player)
        {
            if (!IsCurrentPathCompleteToGoal())
            {
                ResetPlayerPath(selectedPlayer);
            }
        }

        selectedPlayer = player;
        currentPath = new List<Vector2Int>(pathManager.GetPlayerPath(player));

        if (currentPath.Count == 0)
        {
            currentPath.Add(player.GetGridPosition());
        }

        pathVisualizer.InitializePlayerPathRenderer(player);
        OnPlayerSelectionChanged?.Invoke(player);
    }

    // 새로운 메서드 추가
    private void ResetPlayerPath(Player player)
    {
        // 경로 데이터 초기화 (시작점만 남김)
        List<Vector2Int> resetPath = new List<Vector2Int> { player.GetGridPosition() };
        pathManager.SetPlayerPath(player, resetPath);

        // LineRenderer 초기화
        pathVisualizer.UpdatePlayerPath(player, resetPath);

        // UI 업데이트 추가 - 선택 횟수 0으로 리셋
        var selectionsDisplay = GetComponent<RemainingSelectionsDisplay>();
        if (selectionsDisplay != null)
        {
            selectionsDisplay.UpdateSelectionsCount(player, 0); // 0으로 리셋 (시작점 제외하면 선택 0개)
        }
    }

    // 기존 IsPathCompleteToGoal을 현재 경로용으로 분리
    private bool IsCurrentPathCompleteToGoal()
    {
        if (currentPath.Count == 0) return false;
        Vector2Int lastPoint = currentPath[currentPath.Count - 1];
        return pathValidator.IsPlayerOwnGoal(lastPoint, selectedPlayer);
    }

    void AddToPath(Vector2Int gridPos)
    {
        currentPath.Add(gridPos);
        pathManager.SetPlayerPath(selectedPlayer, currentPath);
        pathVisualizer.UpdatePlayerPath(selectedPlayer, currentPath);

        // 선택 횟수 UI 업데이트 추가
        var selectionsDisplay = GetComponent<RemainingSelectionsDisplay>();
        if (selectionsDisplay != null)
        {
            selectionsDisplay.UpdateSelectionsCount(selectedPlayer, currentPath.Count - 1); // 시작점 제외
        }

        if (pathValidator.IsPlayerOwnGoal(gridPos, selectedPlayer))
        {
            CompletePlayerPath();
        }
    }
    public void ClearPlayerSelection()
    {
        OnPlayerSelectionChanged?.Invoke(null);
    }

    // CompletePlayerPath 메서드 수정 - 통합 이벤트 발생
    void CompletePlayerPath()
    {
        pathVisualizer.HideHoverPath();
        pathVisualizer.CompletePlayerPath(selectedPlayer);

        // 통합된 완료 이벤트 발생 (모든 완료 처리를 이것 하나로 통합)
        OnPlayerCompleted?.Invoke(selectedPlayer);

        selectedPlayer = null;
        currentPath.Clear();
    }

    void HandleHoverAndDrag()
    {
        if (selectedPlayer == null || pathManager == null || pathManager.IsAnyPlayerMoving()) return;
        if (IsPathCompleteToGoal()) return;

        // inputHandler null 체크 추가
        if (inputHandler == null) return;

        Vector3 inputWorldPos = inputHandler.GetWorldPosition();

        // GridManager null 체크 추가
        if (GridManager.Instance == null) return;

        Vector2Int inputGridPos = GridManager.Instance.WorldToGrid(inputWorldPos);

        // pathValidator null 체크 추가
        if (pathValidator == null) return;

        if (!pathValidator.HasTileAtPosition(inputGridPos) ||
            !pathValidator.CanAddMorePoints(selectedPlayer, currentPath))
        {
            // pathVisualizer null 체크 추가
            if (pathVisualizer != null)
                pathVisualizer.HideHoverPath();
            return;
        }

        Vector2Int startPos = pathValidator.GetLastPathPoint(selectedPlayer, currentPath);
        if (pathValidator.IsStraightLine(startPos, inputGridPos))
        {
            bool isValid = pathValidator.IsValidPathPoint(inputGridPos, selectedPlayer, currentPath);
            if (pathVisualizer != null)
                pathVisualizer.ShowHoverPath(startPos, inputGridPos, isValid);
        }
        else
        {
            if (pathVisualizer != null)
                pathVisualizer.HideHoverPath();
        }
    }

    bool IsPathCompleteToGoal()
    {
        if (currentPath.Count == 0) return false;
        Vector2Int lastPoint = currentPath[currentPath.Count - 1];
        return pathValidator.IsPlayerOwnGoal(lastPoint, selectedPlayer);
    }

    public bool AreAllPlayersComplete()
    {
        return pathManager.AreAllPlayersComplete();
    }

    public void ExecuteAllPaths()
    {
        // 선택 상태 초기화
        selectedPlayer = null;
        currentPath.Clear();

        pathManager.ExecuteAllPaths();
    }

    public void ClearAllLineRenderers()
    {
        // pathVisualizer null 체크 추가
        if (pathVisualizer != null)
        {
            pathVisualizer.ClearAllLineRenderers();
        }

        // pathManager null 체크 추가
        if (pathManager != null)
        {
            pathManager.ClearAllPaths();
        }
    }
    public void AddPlayerToCache(Player player)
    {
        pathManager.AddPlayerToCache(player);
    }
}using UnityEngine;

public enum TileType
{
    Walkable,    // 이동 가능
    Blocked,     // 막힌 타일
    Start,       // 시작점
    Goal         // 목적지
}

[CreateAssetMenu(fileName = "New Tile Data", menuName = "PathPath/Tile Data")]
public class TileData : ScriptableObject
{
    [Header("Tile Settings")]
    public TileType tileType;
    public string tileName;
    public Sprite tileSprite;
    public Color tileColor = Color.white;

    [Header("Gameplay Properties")]
    public bool isWalkable = true;
    public bool blocksMovement = false;

    [Header("Visual")]
    public Material tileMaterial;

    public bool CanWalkOn()
    {
        return isWalkable && !blocksMovement;
    }
}using UnityEngine;
using System.Collections.Generic;

public class Player : MonoBehaviour
{
    [Header("Player Settings")]
    public int playerID = 1;
    public Color playerColor = Color.red;

    [Header("Movement")]
    public float moveSpeed = 2f;

    private Vector2Int currentGridPos;
    private Vector2Int targetGridPos;
    private List<Vector2Int> plannedPath = new List<Vector2Int>();
    private bool isMoving = false;

    void Start()
    {
        // 현재 월드 위치를 그리드 좌표로 변환
        currentGridPos = GridManager.Instance.WorldToGrid(transform.position);
        targetGridPos = currentGridPos;

        // 정확한 그리드 위치로 스냅
        transform.position = GridManager.Instance.GridToWorld(currentGridPos);

        // 플레이어 색상 설정
        GetComponent<SpriteRenderer>().color = playerColor;
    }
    public void ForceStop()
    {
        plannedPath.Clear();
        isMoving = false;

        // 현재 transform.position을 그대로 유지 (스냅하지 않음)
        // 단순히 이동만 중지하고 현재 위치에서 멈춤
        currentGridPos = GridManager.Instance.WorldToGrid(transform.position);
        targetGridPos = currentGridPos;

        // transform.position은 건드리지 않아서 자연스럽게 현재 위치에서 멈춤
    }
    void Update()
    {
        if (isMoving)
        {
            Vector3 targetWorldPos = GridManager.Instance.GridToWorld(targetGridPos);
            transform.position = Vector3.MoveTowards(transform.position, targetWorldPos, moveSpeed * Time.deltaTime);

            // 도착 확인
            if ((transform.position - targetWorldPos).sqrMagnitude < 0.0001f)
            {
                transform.position = targetWorldPos;
                currentGridPos = targetGridPos;
                isMoving = false;

                // 다음 경로가 있으면 계속 이동
                if (plannedPath.Count > 0)
                {
                    MoveToNextPosition();
                }
            }
        }
    }

    public void SetPath(List<Vector2Int> path)
    {
        plannedPath = new List<Vector2Int>(path);
    }

    public void StartMoving()
    {
        if (plannedPath.Count > 0 && !isMoving)
        {
            MoveToNextPosition();
        }
    }

    private void MoveToNextPosition()
    {
        if (plannedPath.Count > 0)
        {
            targetGridPos = plannedPath[0];
            plannedPath.RemoveAt(0);
            isMoving = true;
        }
    }

    public Vector2Int GetGridPosition()
    {
        // 실제 현재 위치를 Grid 좌표로 변환
        return GridManager.Instance.WorldToGrid(transform.position);
    }

    public bool IsMoving()
    {
        return isMoving;
    }

    public void ClearPath()
    {
        plannedPath.Clear();
        isMoving = false;
    }
}using UnityEngine;

public class GridManager : MonoBehaviour
{
    [Header("Grid Settings")]
    public int gridWidth = 6;
    public int gridHeight = 12;
    public float cellSize = 1f;
    public Vector3 gridCenter = new Vector3(2.5f, 5.5f, 0f);

    private static GridManager instance;
    public static GridManager Instance { get { return instance; } }

    void Awake()
    {
        if (instance == null)
        {
            instance = this;
        }
        else
        {
            Destroy(gameObject);
        }
    }

    // 월드 좌표를 그리드 좌표로 변환
    public Vector2Int WorldToGrid(Vector3 worldPos)
    {
        Vector3 gridPos = worldPos - gridCenter + new Vector3(gridWidth * cellSize / 2f, gridHeight * cellSize / 2f, 0f);
        int x = Mathf.FloorToInt(gridPos.x / cellSize);
        int y = Mathf.FloorToInt(gridPos.y / cellSize);
        return new Vector2Int(x, y);
    }

    // 그리드 좌표를 월드 좌표로 변환
    public Vector3 GridToWorld(Vector2Int gridPos)
    {
        float x = gridCenter.x - (gridWidth * cellSize / 2f) + (gridPos.x + 0.5f) * cellSize;
        float y = gridCenter.y - (gridHeight * cellSize / 2f) + (gridPos.y + 0.5f) * cellSize;
        return new Vector3(x, y, 0f);
    }

    // 그리드 범위 내인지 확인
    public bool IsValidGridPosition(Vector2Int gridPos)
    {
        return gridPos.x >= 0 && gridPos.x < gridWidth &&
               gridPos.y >= 0 && gridPos.y < gridHeight;
    }

#if UNITY_EDITOR
    void OnDrawGizmos()
    {
        // 항상 좌표 표시 (선택 여부와 관계없이)
        if (Application.isPlaying) return; // Play 모드에서는 숨김

        Gizmos.color = Color.yellow;
        Vector3 gridStartPos = gridCenter - new Vector3(gridWidth * cellSize / 2f, gridHeight * cellSize / 2f, 0f);

        // 격자 그리기
        for (int x = 0; x <= gridWidth; x++)
        {
            Vector3 lineStart = gridStartPos + new Vector3(x * cellSize, 0, 0);
            Vector3 lineEnd = lineStart + new Vector3(0, gridHeight * cellSize, 0);
            Gizmos.DrawLine(lineStart, lineEnd);
        }

        for (int y = 0; y <= gridHeight; y++)
        {
            Vector3 lineStart = gridStartPos + new Vector3(0, y * cellSize, 0);
            Vector3 lineEnd = lineStart + new Vector3(gridWidth * cellSize, 0, 0);
            Gizmos.DrawLine(lineStart, lineEnd);
        }

        // 좌표 텍스트 표시
        UnityEditor.Handles.color = Color.white;
        for (int x = 0; x < gridWidth; x++)
        {
            for (int y = 0; y < gridHeight; y++)
            {
                Vector3 cellCenter = gridStartPos + new Vector3((x + 0.5f) * cellSize, (y + 0.5f) * cellSize, 0);
                UnityEditor.Handles.Label(cellCenter, $"({x},{y})", new GUIStyle()
                {
                    normal = { textColor = Color.white },
                    fontSize = 10,
                    alignment = TextAnchor.MiddleCenter
                });
            }
        }
    }
#endif
}using System.Collections.Generic;
using UnityEngine;

public class GameManager : MonoBehaviour
{
    [Header("Game Settings")]
    public int maxSelectionsPerPlayer = 3;
    public int currentLevel = 1;

    [Header("Managers")]
    [SerializeField] private GridManager gridManager;
    private PathInput pathInput;

    [Header("Collision Detection")]
    private bool isSimulationRunning = false;
    private Dictionary<Vector2Int, List<Player>> positionTracker = new Dictionary<Vector2Int, List<Player>>();


    // 싱글톤 패턴
    private static GameManager instance;
    public static GameManager Instance { get { return instance; } }

    void Awake()
    {
        // 싱글톤 설정
        if (instance == null)
        {
            instance = this;
            transform.SetParent(null); // Root로 이동
            DontDestroyOnLoad(gameObject);
            InitializeGame();
        }
        else
        {
            Destroy(gameObject);
        }
    }
    void Update()
    {
        if (isSimulationRunning)
        {
            CheckForCollisions();
        }
    }

    void InitializeGame()
    {
        // GridManager 자동 찾기
        if (gridManager == null)
            gridManager = FindFirstObjectByType<GridManager>();

        // PathInput 캐시
        if (pathInput == null)
            pathInput = FindFirstObjectByType<PathInput>();
    }
    public void StartSimulation()
    {
        if (pathInput != null && pathInput.AreAllPlayersComplete())
        {
            isSimulationRunning = true;
            positionTracker.Clear();

            // UI 및 시각적 요소 정리
            ClearAllSelectionUI();

            pathInput.ExecuteAllPaths();

            // 충돌 감지 시작
            StartCoroutine(CollisionDetectionCoroutine());
        }
    }
    void ClearAllSelectionUI()
    {
        // PlayerSelectionIndicator 정리
        var playerIndicator = FindFirstObjectByType<PlayerSelectionIndicator>();
        if (playerIndicator != null)
        {
            playerIndicator.ClearSelection();
        }

        // GoalSelectionIndicator 정리
        var goalIndicator = FindFirstObjectByType<GoalSelectionIndicator>();
        if (goalIndicator != null)
        {
            goalIndicator.ClearSelection();
        }

        // RemainingSelectionsDisplay 정리
        var selectionsDisplay = FindFirstObjectByType<RemainingSelectionsDisplay>();
        if (selectionsDisplay != null)
        {
            selectionsDisplay.ClearDisplay();
        }
    }
    // 레벨별 선택 수 반환
    public int GetMaxSelections()
    {
        return maxSelectionsPerPlayer;
    }

    // 레벨 완료 처리
    public void CompleteLevel()
    {
        // TODO: 다음 레벨 로딩, 별점 계산 등
    }

    // 레벨 실패 처리
    public void FailLevel()
    {
        Debug.Log("FailLevel() called - Game Over!");
        // TODO: 재시작 UI 표시
    }

    // 게임 재시작
    public void RestartLevel()
    {
        // TODO: 레벨 리셋
    }

    void CheckForCollisions()
    {
        positionTracker.Clear();

        List<Player> allPlayers = PlayerManager.Instance.GetAllPlayers();

        foreach (Player player in allPlayers)
        {
            Vector2Int gridPos = player.GetGridPosition();

            if (!positionTracker.ContainsKey(gridPos))
            {
                positionTracker[gridPos] = new List<Player>();
            }
            positionTracker[gridPos].Add(player);
        }

        foreach (var kvp in positionTracker)
        {
            if (kvp.Value.Count > 1)
            {
                HandleCollision(kvp.Key, kvp.Value);
                return;
            }
        }
    }
    bool AreAllPlayersAtGoal()
    {
        List<Player> allPlayers = PlayerManager.Instance.GetAllPlayers();

        foreach (Player player in allPlayers)
        {
            PlayerSpawnData playerData = PlayerManager.Instance.GetPlayerData(player.playerID);
            if (playerData == null) continue;

            Vector2Int playerCurrentPos = player.GetGridPosition();
            Vector2Int playerGoalPos = playerData.goalPosition;

            if (playerCurrentPos != playerGoalPos)
            {
                return false; // 하나라도 Goal에 없으면 실패
            }
        }

        return true; // 모든 플레이어가 Goal에 있음
    }
    void HandleCollision(Vector2Int collisionPos, List<Player> collidedPlayers)
    {
        isSimulationRunning = false;

        // 모든 플레이어 즉시 정지
        PlayerManager.Instance.StopAllPlayers();

        Debug.Log($"Collision detected at {collisionPos}!");
        Debug.Log("Game Over - Players collided!");

        FailLevel();
    }

    System.Collections.IEnumerator CollisionDetectionCoroutine()
    {
        while (isSimulationRunning)
        {
            // 모든 플레이어가 이동을 완료했는지 확인
            bool allPlayersFinished = true;
            List<Player> allPlayers = PlayerManager.Instance.GetAllPlayers();

            foreach (Player player in allPlayers)
            {
                if (player.IsMoving())
                {
                    allPlayersFinished = false;
                    break;
                }
            }

            if (allPlayersFinished)
            {
                // 추가 검증: 모든 플레이어가 실제 Goal 위치에 있는지 확인
                if (AreAllPlayersAtGoal())
                {
                    isSimulationRunning = false;
                    Debug.Log("All players reached their destinations!");
                    CompleteLevel();
                }
                else
                {
                    isSimulationRunning = false;
                    Debug.Log("Players stopped moving but not all reached goals!");
                    FailLevel();
                }
            }

            yield return new WaitForSeconds(0.1f);
        }
    }

}